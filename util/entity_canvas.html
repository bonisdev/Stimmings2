<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Grid Renderer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: black; /* Ensure the body background is black */
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            display: block;
            image-rendering: pixelated; /* Disable anti-aliasing */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const IMAGE_SPACING = 30; // Reduced spacing between images
        const MIN_IMAGE_SIZE = 32; // Starting size
        const MAX_MAGNIFY_DISTANCE = 250; // Area of effect for magnification and translation
        const MAX_MAGNIFICATION = 3; // Reduced magnification factor for the closest image
        const TRANSLATION_DISTANCE = 40; // Distance to translate images away from the mouse
        const SCROLL_SPEED = 5; // Speed of scrolling
        const SPRING_FORCE = 0.2; // Stronger force pulling back when reaching the max scroll
        const SPRING_DAMPING = 0.8; // Damping factor to make the spring effect smoother
        let images = [];
        let closestImageIndex = -1;
        let scrollOffset = 0;
        let scrollVelocity = 0;

        // Set up canvas to resize with the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false; // Disable anti-aliasing
            renderImagesInGrid();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        async function loadImages() {
            try {
                const response = await fetch('/images');
                const imagesList = await response.json();

                if (!Array.isArray(imagesList)) {
                    throw new Error('Expected an array of image filenames');
                }

                images = await Promise.all(imagesList.map(src => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.src = `/final_compiled/${src}`;
                        img.onload = () => resolve({ img, src });
                        img.onerror = reject;
                    });
                }));

                renderImagesInGrid();
            } catch (error) {
                console.error('Failed to load images:', error.message);
            }
        }

        function renderImagesInGrid(mouseX = canvas.width / 2, mouseY = canvas.height / 2) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fill the background with black color
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const numCols = Math.floor((canvas.width - IMAGE_SPACING) / (MIN_IMAGE_SIZE + IMAGE_SPACING));
            let minDist = Infinity;

            // Calculate maximum scroll height
            const totalRows = Math.ceil(images.length / numCols);
            const maxScroll = Math.max(0, totalRows * (MIN_IMAGE_SIZE + IMAGE_SPACING) - canvas.height);

            // Apply scrolling based on mouse position
            if (mouseY > canvas.height * 0.9) {
                scrollVelocity += SCROLL_SPEED; // Scroll down
            } else if (mouseY < canvas.height * 0.1) {
                scrollVelocity -= SCROLL_SPEED; // Scroll up
            } else {
                scrollVelocity *= 0.9; // Apply friction
            }

            scrollOffset += scrollVelocity;

            // Apply spring force if scrolling beyond limits
            if (scrollOffset < 0) {
                scrollVelocity += -scrollOffset * SPRING_FORCE;
                scrollVelocity *= SPRING_DAMPING;
                scrollOffset += -scrollOffset * SPRING_FORCE * SPRING_DAMPING;
            } else if (scrollOffset > maxScroll) {
                const overshoot = scrollOffset - maxScroll;
                scrollVelocity -= overshoot * SPRING_FORCE;
                scrollVelocity *= SPRING_DAMPING;
                scrollOffset -= overshoot * SPRING_FORCE * SPRING_DAMPING;
            }

            // First pass to determine the closest image
            images.forEach((imageData, index) => {
                const row = Math.floor(index / numCols);
                const col = index % numCols;
                let x = col * (MIN_IMAGE_SIZE + IMAGE_SPACING) + IMAGE_SPACING;
                let y = row * (MIN_IMAGE_SIZE + IMAGE_SPACING) + IMAGE_SPACING - scrollOffset;

                // Calculate distance from mouse pointer
                const dist = Math.hypot(mouseX - (x + MIN_IMAGE_SIZE / 2), mouseY - (y + MIN_IMAGE_SIZE / 2));

                // Determine if this is the closest image
                if (dist < minDist) {
                    minDist = dist;
                    closestImageIndex = index;
                }
            });

            // Second pass to render images with magnification and translation
            images.forEach((imageData, index) => {
                const row = Math.floor(index / numCols);
                const col = index % numCols;
                let x = col * (MIN_IMAGE_SIZE + IMAGE_SPACING) + IMAGE_SPACING;
                let y = row * (MIN_IMAGE_SIZE + IMAGE_SPACING) + IMAGE_SPACING - scrollOffset;

                // Calculate distance from mouse pointer
                const dist = Math.hypot(mouseX - (x + MIN_IMAGE_SIZE / 2), mouseY - (y + MIN_IMAGE_SIZE / 2));

                // Apply translation and shrinking to images within MAX_MAGNIFY_DISTANCE
                let size = MIN_IMAGE_SIZE;
                if (dist < MAX_MAGNIFY_DISTANCE && index !== closestImageIndex) {
                    const normalizedDist = dist / MAX_MAGNIFY_DISTANCE;
                    const translationFactor = 1 - normalizedDist;
                    const angle = Math.atan2(y - mouseY, x - mouseX);

                    x += Math.cos(angle) * TRANSLATION_DISTANCE * translationFactor;
                    y += Math.sin(angle) * TRANSLATION_DISTANCE * translationFactor;

                    // Shrink the image
                    size *= 1 - normalizedDist * 0.5; // Shrink by up to 50%
                } else if (index === closestImageIndex) {
                    // Magnify only the closest image
                    const normalizedDist = 1 - dist / MAX_MAGNIFY_DISTANCE;
                    size += Math.pow(normalizedDist, 2) * (MIN_IMAGE_SIZE * MAX_MAGNIFICATION);
                }

                // Draw the image
                ctx.drawImage(imageData.img, x - size / 2, y - size / 2, size, size);

                // Draw an outline for the closest image
                if (index === closestImageIndex) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - size / 2, y - size / 2, size, size);
                }
            });

            requestAnimationFrame(() => renderImagesInGrid(mouseX, mouseY)); // Continuously update the canvas
        }

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            renderImagesInGrid(mouseX, mouseY);
        });

        canvas.addEventListener('click', () => {
            if (closestImageIndex !== -1) {
                const selectedImage = images[closestImageIndex];
                console.log('Selected Image:', selectedImage.src);
            }
        });

        loadImages();
    </script>
</body>
</html>
